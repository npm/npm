
module.exports = bundle

var npm = require("../npm")
  , path = require("path")
  , log = require("./utils/log")
  , cache = require("./cache")
  , readJson = require("./utils/read-json")
  , mkdir = require("./utils/mkdir-p")
  , fs = require("./utils/graceful-fs")

bundle.usage = "npm bundle <location> [<pkg>]"

function bundle (args, cb) {
  log(args, "bundle")
  var location = args.shift()
    , pkg = args.shift() || "."
  if (!location) return cb(new Error(bundle.usage))
  if (location.charAt(0) !== "/") {
    location = path.join(process.cwd(), location)
  }
  mkdir(location, function (er) {
    if (er) return cb(new Error(bundle.usage))
    npm.config.set("root", location)
    npm.config.set("binroot", null)
    npm.config.set("manroot", null)
    mkdir(npm.dir, function(er) {
      if (er) return log.er(cb, "Error creating "+npm.dir+" for bundling")(er)

      isDirectory(pkg, function(er, dir) {
        if (er) return cb(er)
        if (dir) {
          // just read the package.json from the directory to
          // avoid adding the whole package to the cache
          readJson(path.join(pkg, "package.json"), function (er, data) {
            if (er) {
              return log.er(cb, "Error reading "+pkg+"/package.json")(er)
            }
            install(data, location, cb)
          })
        } else {
          // AND for my NEXT trick...
          // add the pkg to the cache, so that we get its data whether it's
          // a file, name or whatever, and then delete the cache after.
          var ver
          if (pkg.indexOf("@") !== -1) {
            pkg = pkg.split("@")
            ver = pkg[1]
            pkg = pkg[0]
          }
          cache.add(pkg, ver, function (er, data) {
            if (er) {
              return log.er(cb, "Error adding "+pkg+" to bundle cache")(er)
            }
            install(data, location, function(er) {
              cleanup (er, cb)
            })
          })
        }
      })
    })
  })
}

function isDirectory(pkg, cb) {
  if (pkg.match(/^https?:\/\//)) cb()
  else {
    path.exists(pkg, function(exists) {
      if (exists) {
        fs.stat(pkg, function (er, s) {
          if (er) return cb(er)
          cb(er, s.isDirectory())
        })
      } else cb()
    })
  }
}

function install (data, location, cb) {
  if (typeof data.dependencies === 'undefined') {
    return cb(new Error("Package has no dependencies"))
  }
  var depNames = Object.keys(data.dependencies)
    , deps = depNames.map(function (d) {
        var v = data.dependencies[d]
        if (v === "*") v = ""
        return d+"@"+v
      })
  log.verbose(deps, "bundle deps")
  npm.commands.install(deps, function (er) {
    if (er) return cb(er)
    writeBundleShim(location, depNames, function (er) {
      return cb(er)
    })
  })
}

function cleanup (er_, cb) {
  cache.clean(function (er) {
    if (er) log.error(er, "Error cleaning bundle cache")
    return cb(er_)
  })
}

function writeBundleShim (location, depNames, cb) {
  var data = "// generated by npm, please don't touch!\n"
           + "var i = require.paths.indexOf(__dirname)\n"
           + "if (i && i + 1) require.paths.splice(i, 1)\n"
           + "if (i) require.paths.shift(__dirname)\n"
           + depNames.map(JSON.stringify).map(function (d) {
               return "exports["+d+"] = require('./'+"+d+")"
             }).join("\n")
  fs.writeFile(path.join(location, "index.js"), data, cb)
}

